---
title: "하나의 프로세스 안에서 데이터 브로드캐스팅 하기 - 리스트 설계"
date: 2022-11-19T20:28:16+09:00
tags: ["go", "concurrency", "broadcast", "channel"]
draft: false
---

## 목적

고 언어로 짜여질 프로그램 안에서 하나의 고루틴에서 여러 고루틴으로 동일 데이터를 복제 전달하는 라이브러리를 만듭니다.

## 폐기된 설계

원래 설계 방식에서는 `Broadcaster`라는 구조체가 존재하고, 해당 구조체 내부에 입력으로 들어오는 데이터를 쌓아두는 큐 하나와 데이터를 받는 리시버의 수 만큼의 큐가 존재합니다. 데이터를 제공하는 측은 데이터를 받는 하나의 큐에 데이터를 추가하고, 브로드캐스터는 해당 큐에 데이터가 들어올 때마다 동작해서 복사한 후 각 리시버의 큐에 적재합니다. 그리고 각 리시버는 해당 큐에 데이터가 추가되면 꺼내어 가는 형식으로 동작합니다.

![removed_broadcaster](/img/BroadcasterRemoved.svg)

하지만 이 방식은 실제로 사용하기에 몇가지 문제가 있었습니다.

### Lock과 순회를 피할 수가 없어

방식이야 여러가지가 있겠지만, 제가 구현한 방법으로는 결국 리시버를 순회해야하고, 순회하기 위해서는 Read Lock이 필수였습니다. 리시버가 메시지가 많아질 수록 많은 복사가 이루어지고, 리시버가 많아질 수록 순회에 많은 비용이 들게 되는 처참한 구조에서 성능이 제대로 나올리 없었습니다.

대략적으로 하나의 프로듀서가 100000개의 데이터를 보내고, 4096개의 데이터를 쌓을 수 있는 큐를 가진 128개의 리시버가 복제된 데이터를 갖는 경우에 제 2019 인텔 맥북(i9, 16GB ram)에서 20초 정도 걸렸습니다. 만약 데이터가 더 많아지거나, 리시버가 늘어나거나, 큐 사이즈가 늘어난 리시버에 맞게 줄어들거나 한다면, 성능은 더욱 줄어들 것이기에 실사용은 불가능할 것입니다.

## 새로운 설계

이전 설계에 대한 문제인, 락과 리시버에 대한 순회가 필수적이라는 부분을 해결하기 위해서 LISP의 cons를 떠올렸습니다. cons는 간단한 단방향 연결리스트 형식입니다. 각 노드는 데이터와 다음 노드의 포인터를 가지고 있으며, 이 리스트의 사용법으로는 리스트의 맨 앞에 새로운 노드를 추가하고 해당 노드의 포인터를 리스트의 헤더처럼 사용하는 것입니다. 중간 노드의 삭제나 마지막 노드의 삭제는 불가능합니다. 여기까지 읽고 예상하셨듯이, 각 노드는 불변 객체입니다. 그렇기에 데이터가 들어오면 앞에 계속 추가하는 방법으로 각 리시버, 아니 이제부터 클라이언트로 바꾸겠습니다. 각 클라이언트는 자신이 어디까지 읽었는 지에 대한 시퀀스만 기억하고 있다면 해당 리스트를 관리하는 주체에게 헤더의 포인터를 받아서 순회하며 값을 가져갈 수 있을 것입니다.

그럼 한가지 문제가 생깁니다. cons는 리스트의 앞에 추가하는 방법, 즉 새로운 노드 객체를 만들고 다음 노드를 가리키는 포인터에 기존 리스트의 헤더를 두는 방식으로만 리스트에 값을 추가할 수 있습니다. 그렇다면 더 최신의 데이터가 리스트의 앞에 자리잡게 될 것이고, 각 클라이언트는 더 최신의 것부터 읽게 되어서 만약 오래된 데이터부터 처리해야할 경우엔 병목이 될 수 있습니다. 그리고 새로운 데이터를 가져올 때에 매번 헤더를 물어봐야 하는 불편함도 생깁니다. 그래서 cons는 매우 매력적인 자료구조지만 어쩔 수 없이 불변성을 최대한 유지하면서, 가변성을 조금 첨가하는 방식을 채택했습니다.

### 단방향 리스트

```go
type Node struct {
    Timestamp int64
    Data      []byte
    next      *atomic.Pointer[Node]
}

type List struct {
    head  *atomic.Pointer[Node]
    tail  *atomic.Pointer[Node]
    ttl   int64
}
```

`Timestamp`는 해당 노드가 추가된 시간입니다. 클라이언트가 어디까지 데이터를 받을 지 정하는 지표가 될 필드입니다.  
`Data`는 말 그대로 노드가 가지고 있는 데이터로, 최소한의 복제와 최대한의 범용성을 위해 바이트 슬라이스로 지정했습니다.  
`next`, `head`, `tail`은 1.19부터 추가된 `atomic.Pointer[T]`입니다. 가변성이 될 부분인 이 부분은 쓰기는 한번에 하나의 동작만 수행되도록 논리적으로 맞추겠지만, 읽기는 동시에 여럿, 혹은 쓰기와 같이 발생할 수 있기에 `atomic` 타입을 사용하여 표현했습니다.

### 머리를 앞에 두고, 꼬리를 늘리자

`List` 타입의 `head`는 말 그대로 리스트의 첫번째 노드일 것입니다. 단방향 연결리스트니까 `tail` 쪽으로 진행됩니다. 일반적인 단방향 연결 리스트처럼 `head`에 가까울 수록 이전 데이터, `tail`에 가까울 수록 최신 데이터입니다. 그럼 당연하게도 새로운 데이터가 들어온다면 `tail`을 늘릴 것입니다. 했던 말 그대로 데이터가 `Push`된다면, 새로운 노드를 만들어 필드를 채운 후, 리스트 마지막에 추가합니다. 단순하게 `tail`의 노드의 다음 포인터를 새로운 노드로 지정하고, 새 노드의 포인터를 `tail`에 저장합니다.

### 그렇다고 자라는 머리를 안 자를 순 없는데

`head`에 대한 `Shift` 작업이 없다면, 리스트의 데이터는 무한히 늘어나고 언젠가는 OOM(out of memory)을 일으켜 서버가 죽을 것입니다. 그걸 방지하기 위해 전체 길이를 체크하여 증가하지 못 하게 만들 수 있습니다. 하지만 이 방법을 사용하면 `KeepAlive`를 가까스로 달성한 클라이언트가 매우 빠르게 추가된 데이터에 의해, 지난 데이터 중 유효한 데이터를 받지 못 하는 불상사가 발생할 수 있습니다. 그렇기에 `ttl` 필드를 추가해서 지난 시간을 계산하여 꾸준히 `head`부터 길어진 리스트를 자릅니다. `head`부터 순회하여 `ttl`을 만족하는 노드를 찾아, 해당 노드의 포인터를 `head`의 포인터로 변경하면 GC(garbage collector)가 `head` 이전 노드들을 수집해서 제거할 것입니다.

### 클라이언트는 어떻게 순회하지?

클라이언트가 `List`를 순회하는 방법에는 여러가지가 있지만, 제가 선택한 방법은 콜백입니다. 만약 `List`에 `Iterate`이란 메서드가 존재한다면, 콜백 함수를 매개변수로 받아 `Iterate(func(*Node))`같은 느낌으로 정의될 것입니다.

```go
type Iterator struct {
    cur      *atomic.Pointer[Node]
    callback func(*Node)
}

func (i Iterator) Next() bool {
    c := i.cur.Load()
    n := c.next.Load()
    i.callback(c)
    i.cur.Store(n)
    return n != nil
}
```

그리고 `Next() bool`라는 메서드를 통해 다음으로 진행되도록 합니다. `nil`이면 `false`, 아니면 `true`를 반환하며 계속 실행해 나갑니다. 클라이언트는 자신들만의 적절한 조건에 따라 계속 시도할지, 끊을 지 등을 결정합니다. 예를 들어 데이터가 더 이상 추가되지 않아서 계속 `false`가 된다면, 해당 포인터가 잘못되었다고 판단하고 적절한 시간 이후 `List`에 다시 `head`나 `tail`을 요구하는 방법이 있을 수 있습니다. 다른 경우로는 더 이상 이 `List`가 유효하지 못 하다고 판단하여, `List`에 대한 구독 자체를 중지하는 수도 있습니다. 각각의 경우는 이 라이브러리가 쓰이는 곳에 따라 달라질 것이라 설계 단계에서 거기까지 고려하지는 않겠습니다.

### 머리와 꼬리의 가변에 대해서

사실 논리적으로 `head`와 `tail`이 수정되는 부분은 원자성 있게 진행되는 게 맞다고 생각하고 있습니다. 그리고 그렇게 진행하기 위해 처음에 `sync.Mutex`를 사용할까 생각했습니다. 하지만 제가 이 라이브러리를 써야할 곳이 데이터가 들어온 순서를 어느정도는 보장해 주는 것이 중요하다고 판단했습니다. 그래서 `chan []byte`나 [`go-datastructurs`](https://github.com/Workiva/go-datastructures)의 [`ringbuffer`](https://github.com/Workiva/go-datastructures/blob/master/queue/ring.go)를 사용해서 데이터를 입력 받고, 하나의 고루틴 안에서 실행되는 `for range`나 `for {}` 구문을 통해 입력 데이터를 하나 씩, 순차적으로 처리하는 걸 생각하고 있습니다. 입력에 당연히 어느정도의 코스트가 쓰일 것으로 예상이 되나, 전달해 주는 부분이 문제라고 파악했기에 일단은 이렇게 설계합니다. 이 부분은 다음 포스트에서 다시 작성하겠습니다.

### 결론적으로

데이터를 복제해서 전달해주는 방식이 아니라, 클라이언트가 어느정도의 위험성을 가지고 데이터를 가지고 가는 방식이라 충분히 성능 상의 이점이 있지 않을까 기대하고 있습니다. 두가지 정도 거슬리는 부분은 연결 리스트라서 메모리의 로컬리티를 살리기 어렵다는 것과, `sync.Pool`을 사용하면 어느정도 객체를 풀링하였을 때 과하게 많아지면 OOM에 근접할 수 있지 않을까하는 부분입니다.
