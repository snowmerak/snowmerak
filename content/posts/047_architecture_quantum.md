---
title: "아키텍처의 퀀텀"
date: 2025-07-04T05:18:45Z
author: snowmerak
tags: ["architecture"]
categories: ["Information"]
draft: false
---

## What is Quantum?

퀀텀은 라틴어 'quantus'에서 유래했으며, '얼마나 많은', '양의'를 의미합니다. 이외에도 사전 상에서 다음과 같은 의미를 찾을 수 있습니다.

- (물리학) 양자: 더 이상 나눌 수 없는 에너지나 물질의 최소 단위.
- (일반적으로) 최소량, 일정량.
- 갑작스럽고 중요한 도약을 의미할 때도 사용

### 아키텍처에선?

아키텍처에서는 사전적 의미의 `최소량`의 의미를 가지고 쓰이게 됩니다. 아키텍처에서 최소량은 어떤 걸 의미하는 걸까요? 저희는 일반적으로 한번에 배포될 수 있는 단위를 퀀텀이라고 부르게 됩니다.

최근 마이크로서비스 아키텍처 트렌드와 시스템의 복잡성 증가, 그리고 빠른 비즈니스 요구사항 변화에 유연하게 대처하기 위한 필요성이 커지면서 아키텍처에서의 퀀텀 개념은 더욱 중요해졌습니다. 각 서비스를 독립적인 퀀텀으로 설계하고 배포함으로써, 시스템의 특정 부분만 빠르게 업데이트하거나 확장하고, 장애 발생 시 영향 범위를 최소화할 수 있습니다.

예를 들어, 대규모의 복잡한 시스템을 개발할 때 전체를 하나의 거대한 단위로 관리한다면 변경 및 배포 과정이 매우 느려지고 위험해질 수 있습니다. 하지만 시스템을 여러 개의 작은 퀀텀으로 나누어 관리하면, 각 퀀텀은 독립적으로 개발, 테스트, 배포될 수 있어 전체 시스템의 민첩성과 안정성을 높일 수 있습니다. 즉, 퀀텀은 복잡한 시스템을 이해하고 관리하기 위한 논리적인 분할 단위이자, 효율적인 개발 및 운영을 가능하게 하는 핵심 개념이라고 할 수 있습니다.

단일 시스템이든, 분산 시스템이든, 아키텍처를 설계할 때 "어떤 단위를 묶어서 함께 배포할 것인가?" 그리고 "각 단위는 어떤 책임과 범위를 가질 것인가?"에 대한 고민은 매우 중요하며, 이것이 곧 아키텍처 퀀텀을 정의하는 과정입니다. 이러한 퀀텀의 범위를 명확히 함으로써 우리는 시스템의 의존성을 파악하고, 변경의 파급 효과를 예측하며, 더 나아가 유연하고 확장 가능한 아키텍처를 구축할 수 있게 됩니다.

이러한 배경 속에서 '아키텍처의 퀀텀'이라는 개념은 단순한 용어 이상의 의미를 가지며, 효과적인 소프트웨어 아키텍처 설계 및 운영을 위한 필수적인 고려 사항이 되었습니다.

### 가정해볼까요?

예를 들어, 채팅 서버를 서버를 구성한다고 가정해보죠. 단일 서버로만 올릴 건 아니니까, 당연히 여러 서버 인스턴스가 올라가게 될 겁니다. 여러 서버 인스턴스가 올라가게 되면 메시지를 중계해줄 메시지큐나 브로커가 필요합니다. 세션 관리를 위한 분산 캐시와 사용자 관리를 위한 데이터베이스나 채팅 기록을 위한 데이터베이스도 필요할 겁니다. 필요에 의해선 파일 저장소도 필요할 수 있습니다. 

채팅 서버 하나를 올리기 위해 다음 인프라가 추가로 필요한 거죠.
- Message Queue or Message Broker
  - NATS
  - Kafka
  - Pulsar
  - etc..
- Distributed Cache
  - Redis cluster
  - Valkey cluster
  - MongoDB
  - Memcached
  - etc...
- OLTP Database
  - Postgres
  - MySQL
  - MSSQL
  - etc...
- OLAP Database
  - MongoDB
  - Cassandra
  - Clickhouse
  - etc...

제가 생각하는 최적의 조합으로 채팅 서버를 하나 올리게 되면,
- Go로 된 채팅 서버 하나
- 레디스 노드 하나
- 포스트그레 하나
- 클릭하우스 하나

이렇게 4개 구성이 방금 가정한 채팅 서버가 가지는 아키텍처에서의 퀀텀이 될 겁니다.

#### 온라인 쇼핑몰

온라인 쇼핑몰에서는 다음과 같이 퀀텀을 정의해 볼 수 있습니다.

- 주문 처리 퀀텀: 주문 접수 서비스, 결제 처리 서비스, 재고 관리 서비스, 배송 정보 생성 서비스 등을 묶어 하나의 퀀텀으로 볼 수 있습니다. 이 퀀텀은 고객이 상품을 주문하고 최종적으로 배송이 시작되기까지의 핵심 비즈니스 로직을 담당하며, 각 서비스는 독립적으로 배포될 수 있지만 주문이라는 도메인 책임을 공유합니다.
- 상품 정보 퀀텀: 상품 정보 조회 서비스, 상품 리뷰 서비스, 상품 추천 서비스 등을 묶어 또 다른 퀀텀으로 볼 수 있습니다. 이 퀀텀은 고객에게 상품 정보를 제공하고 상호작용을 유도하는 역할을 하며, 주문 처리 퀀텀과는 독립적으로 변경 및 배포가 가능합니다.

#### 게임 서비스

게임 서비스의 경우에도 다양한 퀀텀으로 분리하여 설계할 수 있습니다.

- 매치메이킹 퀀텀: 사용자 매칭 서비스, 게임 세션 생성 서비스, 게임 시작 알림 서비스 등을 포함할 수 있습니다. 이 퀀텀은 플레이어들이 함께 게임을 할 수 있도록 연결하는 역할을 담당하며, 빠른 반응성과 확장성이 요구될 수 있습니다.
- 인벤토리 퀀텀: 사용자 아이템 관리 서비스, 아이템 구매/판매 서비스, 아이템 조합 서비스 등을 포함하는 퀀텀입니다. 플레이어의 자산과 관련된 민감한 정보를 다루므로 높은 일관성과 보안이 중요하며, 다른 퀀텀과 분리하여 관리함으로써 독립적인 보안 강화 및 데이터 일관성 유지가 가능합니다.

이처럼 퀀텀은 시스템의 특정 비즈니스 기능이나 도메인 책임을 중심으로 정의될 수 있으며, 이는 아키텍처를 더 작고 관리 가능한 단위로 분할하여 개발, 배포, 운영의 효율성을 높이는 데 기여합니다.

### 퀀텀의 범위

이러한 퀀텀의 범위는 도메인이나 생산되는 데이터의 책임 범위와 유사합니다. 위의 채팅만 봐도 그렇습니다. 채팅 서비스 하나를 구성하기 위한 퀀텀에 포함된 각 인프라의 역할과 책임 범위를 보면 더욱 명확하게 알 수 있습니다.

- 채팅 서버 => 유저로부터 채팅을 받고 필요한 정책적 처리 및 전송 과정을 담당합니다.
- 레디스 노드 => 각 유저 세션이나 chat room 등의 캐싱을 담당하고, 공통된 환경 변수, 정책에 필요한 데이터의 캐싱 등의 공유를 담당합니다.
  - 필요에 따라 Refresh Token같은 걸로 세션을 대체할 수도 있을 겁니다.
- 포스트그레 => 각 유저 데이터나 chat room 데이터 등의 레디스에서 쓰이는 데이터의 오리지널 데이터의 저장을 담당합니다.
  - 필요에 따라 유저 인증과 관련된 API Key나 Secret을 저장할 수도 있을 겁니다.
- 클릭하우스 => 역대 채팅 서버를 통해 공유된 메시지나 이벤트 등의 내용을 저장하고 제공하는 걸 담당합니다.

## 그럼 왜 퀀텀을?

### 퀀텀의 범위

이러한 퀀텀의 범위는 도메인이나 생산되는 데이터의 책임 범위와 유사합니다. 위의 채팅만 봐도 그렇습니다. 채팅 서비스 하나를 구성하기 위한 퀀텀에 포함된 각 인프라의 역할과 책임 범위를 보면 더욱 명확하게 알 수 있습니다.

- 채팅 서버 => 유저로부터 채팅을 받고 필요한 정책적 처리 및 전송 과정을 담당합니다.
- 레디스 노드 => 각 유저 세션이나 chat room 등의 캐싱을 담당하고, 공통된 환경 변수, 정책에 필요한 데이터의 캐싱 등의 공유를 담당합니다.
  - 필요에 따라 Refresh Token같은 걸로 세션을 대체할 수도 있을 겁니다.
- 포스트그레 => 각 유저 데이터나 chat room 데이터 등의 레디스에서 쓰이는 데이터의 오리지널 데이터의 저장을 담당합니다.
  - 필요에 따라 유저 인증과 관련된 API Key나 Secret을 저장할 수도 있을 겁니다.
- 클릭하우스 => 역대 채팅 서버를 통해 공유된 메시지나 이벤트 등의 내용을 저장하고 제공하는 걸 담당합니다.

물론 다른 곳에서 채팅 데이터를 가지고 검색을 만든다거나, 관심사를 추출한다거나, 하는 다양한 행위를 할 수 있을 테지만, 생산과 보존은 채팅 서비스에서 수행하는 것이죠.

### 알아야 하는 이유

이는 다른 서비스와 얼마나 독립적으로 동작할 수 있는 지를 정의하는 데에 중요한 지표가 됩니다. 물론 그렇다하더라도 퀀텀이란 단어를 알 필요는 없습니다. 다만, 그에 대한 개념은 있으면 좋다고 생각합니다.

퀀텀이란 개념을 알게 됨으로, 어떤 서비스나 패키지 등을 설계 및 구성할 때,
- 독립적으로 배포되기 위해 얼마나 작은 범위까지 분리시킬지 고려하고,
- 얼마나 서비스에 큰 영향을 주며 배포되는지 파악할 수 있으며,
- 추후 서비스나 아키텍처에 대한 변경 발생 시 발생되는 파장이 얼마나 클지, 그리고 적절한 위치에서 해당 파장을 격리시킬 수 있을 지 정할 수 있을 거기 때문입니다.

예를 들어, 방금 채팅 서비스에 접근하기 위한 인증과 chatroom에 대한 관리를 멤버십 서비스가 담당한다고 가정해봅시다. 그러면 멤버십 서비스가 장애가 나거나, 내부 네트워크 문제로 인해 서로 다른 서비스 간의 통신이 단절되거나 하면, 채팅 서비스도 장애를 공유받게 됩니다. 이 경우엔 채팅 서비스에 대한 퀀텀에 멤버십 서비스가 포함되게 되겠죠.

하지만 채팅 서비스가 온전히 자신만의 퀀텀을 가지고, 멤버십에서 오히려 채팅 서비스에 유저 접근을 위한 토큰 발급을 요청하고, 해당 토큰을 유저에게 제공한 후 채팅 서비스에 접근하도록 한다면, 위의 멤버십에 대한 장애가 발생해도 채팅 서비스 자체는 유저들이 원할히 이용할 수 있을 겁니다.

## 마지막으로

정말 별거 아닌 기초적인 용어이지만, 개념을 알고 모르고의 차이가 설계 레벨에서 의외로 큰 차이를 보인다는 걸 느끼고 있었습니다. 그러던 중 퀀텀이란 단어를 알게 되어 오랜만에 포스팅을 했는데, 처음 아키텍처링을 접하는 분들에게 도움이 되기를 바랍니다.
