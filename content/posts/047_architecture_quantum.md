---
title: "아키텍처의 퀀텀"
date: 2025-07-04T05:18:45Z
author: snowmerak
tags: ["architecture"]
categories: ["Information"]
draft: false
---

## 퀀텀이란 무엇인가?

퀀텀은 라틴어 'quantus'에서 유래했으며, '얼마나 많은', '양의'를 의미합니다. 이외에도 사전 상에서 다음과 같은 의미를 찾을 수 있습니다:

- (물리학) 양자: 더 이상 나눌 수 없는 에너지나 물질의 최소 단위
- (일반적으로) 최소량, 일정량
- 갑작스럽고 중요한 도약을 의미할 때도 사용

### 아키텍처에서의 퀀텀

아키텍처에서는 사전적 의미의 `최소량`의 의미를 가지고 쓰이게 됩니다. 아키텍처에서 최소량은 어떤 걸 의미하는 걸까요? 저희는 일반적으로 한번에 배포될 수 있는 단위를 퀀텀이라고 부르게 됩니다.

최근 마이크로서비스 아키텍처 트렌드와 시스템의 복잡성 증가가 이어지고 있습니다. 또한 빠른 비즈니스 요구사항 변화에 유연하게 대처하기 위한 필요성이 커지면서 아키텍처에서의 퀀텀 개념은 더욱 중요해졌습니다. 각 서비스를 독립적인 퀀텀으로 설계하고 배포함으로써, 시스템의 특정 부분만 빠르게 업데이트하거나 확장할 수 있습니다. 그리고 장애 발생 시 영향 범위를 최소화할 수 있습니다.

예를 들어, 대규모의 복잡한 시스템을 개발할 때 전체를 하나의 거대한 단위로 관리한다면 변경 및 배포 과정이 매우 느려지고 위험해질 수 있습니다. 하지만 시스템을 여러 개의 작은 퀀텀으로 나누어 관리하면, 각 퀀텀은 독립적으로 개발, 테스트, 배포될 수 있습니다. 이를 통해 전체 시스템의 민첩성과 안정성을 높일 수 있습니다. 즉, 퀀텀은 복잡한 시스템을 이해하고 관리하기 위한 논리적인 분할 단위입니다. 동시에 효율적인 개발 및 운영을 가능하게 하는 핵심 개념이라고 할 수 있습니다.

단일 시스템이든, 분산 시스템이든, 아키텍처를 설계할 때 중요한 질문들이 있습니다. "어떤 단위를 묶어서 함께 배포할 것인가?" 그리고 "각 단위는 어떤 책임과 범위를 가질 것인가?"에 대한 고민은 매우 중요합니다. 이것이 곧 아키텍처 퀀텀을 정의하는 과정입니다. 이러한 퀀텀의 범위를 명확히 함으로써 우리는 시스템의 의존성을 파악할 수 있습니다. 변경의 파급 효과를 예측할 수 있습니다. 더 나아가 유연하고 확장 가능한 아키텍처를 구축할 수 있게 됩니다.

이러한 배경 속에서 '아키텍처의 퀀텀'이라는 개념은 단순한 용어 이상의 의미를 가집니다. 효과적인 소프트웨어 아키텍처 설계 및 운영을 위한 필수적인 고려 사항이 되었습니다.

### 실제 예시로 이해하기

#### 채팅 서버

예를 들어, 채팅 서버를 구성한다고 가정해보죠. 단일 서버로만 올릴 건 아니니까, 당연히 여러 서버 인스턴스가 올라가게 될 겁니다. 여러 서버 인스턴스가 올라가게 되면 메시지를 중계해줄 메시지큐나 브로커가 필요합니다. 세션 관리를 위한 분산 캐시와 사용자 관리를 위한 데이터베이스나 채팅 기록을 위한 데이터베이스도 필요할 겁니다. 필요에 의해선 파일 저장소도 필요할 수 있습니다. 

채팅 서버 하나를 올리기 위해 다음 인프라가 추가로 필요한 거죠:

- Message Queue or Message Broker
  - NATS
  - Kafka
  - Pulsar
  - etc.
- Distributed Cache
  - Redis cluster
  - Valkey cluster
  - MongoDB
  - Memcached
  - etc.
- OLTP Database
  - Postgres
  - MySQL
  - MSSQL
  - etc.
- OLAP Database
  - MongoDB
  - Cassandra
  - Clickhouse
  - etc.

제가 생각하는 최적의 조합으로 채팅 서버를 하나 올리게 되면:

- Go로 된 채팅 서버 하나
- 레디스 노드 하나
- 포스트그레 하나
- 클릭하우스 하나

이렇게 4개 구성이 방금 가정한 채팅 서버가 가지는 아키텍처에서의 퀀텀이 될 겁니다.

#### 온라인 쇼핑몰

온라인 쇼핑몰에서는 다음과 같이 퀀텀을 정의해 볼 수 있습니다.

- 주문 처리 퀀텀: 주문 접수 서비스, 결제 처리 서비스, 재고 관리 서비스, 배송 정보 생성 서비스 등을 묶어 하나의 퀀텀으로 볼 수 있습니다. 이 퀀텀은 고객이 상품을 주문하고 최종적으로 배송이 시작되기까지의 핵심 비즈니스 로직을 담당하며, 각 서비스는 독립적으로 배포될 수 있지만 주문이라는 도메인 책임을 공유합니다.
- 상품 정보 퀀텀: 상품 정보 조회 서비스, 상품 리뷰 서비스, 상품 추천 서비스 등을 묶어 또 다른 퀀텀으로 볼 수 있습니다. 이 퀀텀은 고객에게 상품 정보를 제공하고 상호작용을 유도하는 역할을 하며, 주문 처리 퀀텀과는 독립적으로 변경 및 배포가 가능합니다.

#### 게임 서비스

게임 서비스의 경우에도 다양한 퀀텀으로 분리하여 설계할 수 있습니다.

- 매치메이킹 퀀텀: 사용자 매칭 서비스, 게임 세션 생성 서비스, 게임 시작 알림 서비스 등을 포함할 수 있습니다. 이 퀀텀은 플레이어들이 함께 게임을 할 수 있도록 연결하는 역할을 담당하며, 빠른 반응성과 확장성이 요구될 수 있습니다.
- 인벤토리 퀀텀: 사용자 아이템 관리 서비스, 아이템 구매/판매 서비스, 아이템 조합 서비스 등을 포함하는 퀀텀입니다. 플레이어의 자산과 관련된 민감한 정보를 다루므로 높은 일관성과 보안이 중요하며, 다른 퀀텀과 분리하여 관리함으로써 독립적인 보안 강화 및 데이터 일관성 유지가 가능합니다.

이처럼 퀀텀은 시스템의 특정 비즈니스 기능이나 도메인 책임을 중심으로 정의될 수 있습니다. 이는 아키텍처를 더 작고 관리 가능한 단위로 분할하여 개발, 배포, 운영의 효율성을 높이는 데 기여합니다.

## 퀀텀의 책임과 범위

퀀텀의 범위는 도메인이나 생산되는 데이터의 책임 범위와 유사합니다. 위의 채팅 예시를 통해 살펴보면 더욱 명확하게 알 수 있습니다. 채팅 서비스 하나를 구성하기 위한 퀀텀에 포함된 각 인프라의 역할과 책임 범위를 보겠습니다:

- **채팅 서버**: 유저로부터 채팅을 받고 필요한 정책적 처리 및 전송 과정을 담당합니다.
- **레디스 노드**: 각 유저 세션이나 chat room 등의 캐싱을 담당하고, 공통된 환경 변수, 정책에 필요한 데이터의 캐싱 등의 공유를 담당합니다.
  - 필요에 따라 Refresh Token같은 걸로 세션을 대체할 수도 있을 겁니다.
- **포스트그레**: 각 유저 데이터나 chat room 데이터 등의 레디스에서 쓰이는 데이터의 오리지널 데이터의 저장을 담당합니다.
  - 필요에 따라 유저 인증과 관련된 API Key나 Secret을 저장할 수도 있을 겁니다.
- **클릭하우스**: 역대 채팅 서버를 통해 공유된 메시지나 이벤트 등의 내용을 저장하고 제공하는 걸 담당합니다.

물론 다른 곳에서 채팅 데이터를 가지고 검색을 만든다거나, 관심사를 추출한다거나, 하는 다양한 행위를 할 수 있을 테지만, 생산과 보존은 채팅 서비스에서 수행하는 것이죠.

## 퀀텀을 알아야 하는 이유

퀀텀 개념을 이해하는 것은 아키텍처를 설계하고 발전시키는 데 있어 여러 면에서 중요한 통찰을 제공합니다. 이는 단순히 용어를 아는 것을 넘어, 시스템의 독립성, 변경의 영향 범위, 그리고 장애 격리 능력 등을 판단하는 기준이 됩니다.

### 독립적 배포와 개발

시스템을 퀀텀 단위로 분할하면, 각 퀀텀은 독립적으로 개발, 테스트, 배포될 수 있습니다. 대규모 모놀리식 아키텍처에서는 작은 기능 변경에도 전체 시스템을 다시 빌드하고 배포해야 할 수 있습니다. 이는 시간 소모적이고 위험 부담이 큽니다.

하지만 퀀텀 단위로 분리된 아키텍처에서는 변경이 발생한 특정 퀀텀만 업데이트하면 됩니다. 따라서 배포 속도를 높이고 롤백의 복잡성을 줄일 수 있습니다. 이는 팀의 생산성과 시스템의 민첩성을 향상시킵니다.

### 영향 범위 파악과 격리

시스템의 한 부분에서 발생한 변경이 다른 부분에 미치는 영향을 퀀텀 개념을 통해 명확하게 파악할 수 있습니다. 만약 특정 퀀텀 내에서 변경이 발생했다면, 해당 변경이 다른 퀀텀에 미치는 직접적인 영향을 예측하고 관리하기 쉬워집니다.

모놀리식 시스템에서는 의존성이 복잡하게 얽혀 있어 작은 변경이 예상치 못한 큰 파급 효과를 가져오기 쉽습니다. 퀀텀은 이러한 의존성의 경계를 정의하고, 변경의 영향 범위를 국한시키는 데 도움을 줍니다.

퀀텀은 시스템의 각 부분을 논리적으로 격리하는 역할을 합니다. 예를 들어, 외부 서비스와의 연동을 담당하는 퀀텀에서 외부 서비스의 장애가 발생하더라도, 이 장애가 다른 퀀텀으로 전파되지 않도록 격리할 수 있습니다. 이는 서킷 브레이커(Circuit Breaker)와 같은 디자인 패턴과 함께 활용될 때 시스템의 탄력성을 크게 향상시킵니다.

### 실전 적용 사례

실제 사례를 통해 퀀텀의 효과를 살펴보겠습니다. 채팅 서비스에 접근하기 위한 인증과 chatroom에 대한 관리를 멤버십 서비스가 담당한다고 가정해봅시다. 그러면 멤버십 서비스가 장애가 나거나, 내부 네트워크 문제로 인해 서로 다른 서비스 간의 통신이 단절되면, 채팅 서비스도 장애를 공유받게 됩니다. 이 경우엔 채팅 서비스에 대한 퀀텀에 멤버십 서비스가 포함되게 되겠죠.

하지만 채팅 서비스가 온전히 자신만의 퀀텀을 가지고, 멤버십에서 오히려 채팅 서비스에 유저 접근을 위한 토큰 발급을 요청하고, 해당 토큰을 유저에게 제공한 후 채팅 서비스에 접근하도록 한다면 어떨까요? 위의 멤버십에 대한 장애가 발생해도 채팅 서비스 자체는 유저들이 원활히 이용할 수 있을 겁니다.

이처럼 퀀텀 개념을 통해 우리는 시스템을 더 작고 관리 가능한 단위로 분할할 수 있습니다. 각 단위의 책임과 의존성을 명확히 하며, 변경 및 장애에 대한 시스템의 탄력성을 높일 수 있습니다.

## 적절한 퀀텀 크기 결정하기

퀀텀의 크기를 결정하는 것은 아키텍처 설계에서 가장 중요한 결정 중 하나입니다. 너무 크거나 작은 퀀텀은 모두 문제를 야기할 수 있습니다.

### 팀 크기 고려사항

**2-Pizza 팀 원칙**: 한 팀이 관리할 수 있는 퀀텀의 크기는 팀 규모와 밀접한 관련이 있습니다. 일반적으로 5-8명 정도의 팀이 하나의 퀀텀을 효과적으로 관리할 수 있습니다.

**개발자 전문성**: 팀 내 개발자들의 기술 스택과 도메인 지식이 퀀텀의 범위를 결정하는 요소가 됩니다. 팀이 효과적으로 개발하고 유지보수할 수 있는 기술 범위 내에서 퀀텀을 설계해야 합니다.

### 복잡도와 배포 주기

**비즈니스 복잡도**: 단일 비즈니스 기능을 담당하는 퀀텀이 이상적입니다. 여러 비즈니스 도메인이 얽혀있다면 퀀텀을 분리하는 것을 고려해야 합니다.

**배포 빈도**: 자주 변경되는 부분과 안정적인 부분을 분리하여 각각 다른 퀀텀으로 관리하면 배포 효율성을 높일 수 있습니다.

**데이터 일관성 요구사항**: 강한 일관성이 필요한 데이터들은 같은 퀀텀 내에 배치하고, 최종 일관성으로 충분한 데이터들은 분리할 수 있습니다.

## 주의사항과 안티패턴

퀀텀을 잘못 설계하면 오히려 시스템의 복잡성을 증가시킬 수 있습니다.

### 너무 작은 퀀텀의 문제점

**과도한 분산화**: 기능 하나하나를 모두 별도 퀀텀으로 분리하면 네트워크 오버헤드가 증가하고 전체 시스템의 성능이 저하될 수 있습니다.

**복잡한 오케스트레이션**: 퀀텀 간의 조율이 복잡해져 전체 시스템의 이해도가 떨어집니다.

**높은 운영 비용**: 각 퀀텀마다 별도의 인프라, 모니터링, 로깅이 필요해 운영 복잡성이 증가합니다.

### 너무 큰 퀀텀의 문제점

**모놀리식 회귀**: 퀀텀이 너무 크면 결국 모놀리식 시스템과 다를 바 없게 됩니다.

**배포 리스크**: 큰 퀀텀은 변경의 영향 범위가 넓어져 배포 시 리스크가 증가합니다.

**팀 간 결합도 증가**: 여러 팀이 하나의 큰 퀀텀을 관리하게 되면 팀 간 조율 비용이 증가합니다.

### 잘못된 경계 설정

**데이터 공유 퀀텀**: 여러 퀀텀이 같은 데이터베이스를 공유하면 진정한 독립성을 확보할 수 없습니다.

**순환 의존성**: 퀀텀 간에 순환 의존성이 발생하면 독립적인 배포가 불가능해집니다.

**부적절한 도메인 분할**: 비즈니스적으로 밀접한 기능들을 억지로 분리하면 데이터 일관성 문제가 발생할 수 있습니다.

### 퀀텀 효과성 측정 방법

**배포 빈도 측정**: 각 퀀텀의 배포 빈도를 측정하여 독립성을 평가할 수 있습니다. 다른 퀀텀의 배포에 의존하는 경우가 빈번하다면 경계를 재검토해야 합니다.

**장애 영향도 분석**: 한 퀀텀의 장애가 다른 퀀텀에 미치는 영향을 측정합니다. 격리가 잘 되어있다면 장애의 파급 효과가 제한적이어야 합니다.

**개발 속도 지표**: 퀀텀 분할 전후의 개발 속도를 비교하여 효과를 측정할 수 있습니다. 기능 개발 시간, 버그 수정 시간 등을 추적합니다.

## 마지막으로

정말 별거 아닌 기초적인 용어이지만, 개념을 알고 모르고의 차이가 설계 레벨에서 의외로 큰 차이를 보인다는 걸 느끼고 있었습니다. 그러던 중 퀀텀이란 단어를 알게 되어 오랜만에 포스팅을 했는데, 처음 아키텍처링을 접하는 분들에게 도움이 되기를 바랍니다.

현대의 복잡하고 빠르게 변화하는 소프트웨어 환경에서 안정적이고 확장 가능한 아키텍처를 구축하는 데 퀀텀 개념은 필수적인 요소입니다. 적절한 퀀텀 설계를 통해 더 나은 시스템을 만들어 나가시기 바랍니다.
